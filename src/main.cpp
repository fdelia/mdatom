/*---------------------FILE MAIN.CC   #5 of 10----------------------------*/

/* C++ version 1.0, gee, 10/01
 * posix compliant time functions, 11/99 hschafer
 * w.f. van gunsteren, groningen, feb. 1988
 * h.j.w. spoelder, amsterdam, C-version 1.0, feb. 88
 * mph, ETH Zurich, 01/2015, removed tapes
 *
 *     main(argc, argv)
 *
 *     main induces a molecular dynamics run for a collection of
 *     atoms.
 *     periodic boundary conditions are applied.
 *     the temperature can be controlled.
 *
 *     an initial configuration can be generated by function confa.
 *     initial velocities can be generated using function gauss.
 *     random numbers are supplied by function a_random.
 *     the md-run is performed by function runmda.
 *     the interaction is calculated by function forcea.
 *     the atoms are kept in the central box by function shia.
 *     center of mass coordinates and motion is computed by function cenma.
 *     atomic trajectories are written to disk by function packa.
 *     the radial distribution function is plotted by function plot.
 *     the program is organized as follows:
 *     main/function name:
 *     1. main
 *        1.1. confa
 *             1.1.1. a_random
 *        1.2. gauss
 *             1.2.1. a_random
 *        1.3. runmda
 *             1.3.1. forcea
 *             1.3.2. shia
 *             1.3.3. cenma
 *             1.3.4. packa
 *        1.4. plot
 *
 *     all parameters are transferred to the function as function arguments.
 *
 *     the array-sizes are specified globally (in mdprog.h).
 *
 *     initialization data are read from the files specified on the command line (argv[1] and argv[2]).
 *     md trajectories can be written to trajectory_filename (coordinates).
 *     final coordinates and velocities are written to finalcoords_filename.
 *
 *     argv[1] (md-run data):
 *     title = arbitrary text, identifying md-run, is written to trajectory_filename
 *             and finalcoords_filename
 *     nat = number of atoms
 *     ntxi = 0 : coordinates x are generated by function confa,
 *                lattice positions with random displacements;
 *                velocities (v) are set equal to zero
 *          = 1 : x is read from argv[2] (formatted), velocities=0
 *          = 2 : x is read from argv[2] (unformatted), velocities=0
 *          = 3 : x and v are read from argv[2] (formatted)
 *          = 4 : x and v are read from argv[2] (unformatted)
 *     ntxo = 0 : final coordinates and velocities are written to
 *                finalcoords_filename (unformatted)
 *          = 1 : idem, but formatted
 *     box(1..3) = lengths of the edges of the periodic box (>0)
 *     nbox(1..3) = number of atoms to be placed along each edge of the
 *                  box (>0, ntxi=0)
 *     dx = maximum spread of the atom positions around the lattice
 *          points (ntxi=0)
 *     ig = random number generator seed (ntxi=0 or tempi>1.e-6)
 *     tempi : if (tempi>1.e-6), the velocities are taken from a
 *          maxwellian distribution with temperature tempi
 *     ntt = 0 : classical md, no coupling to temperature bath
 *         = 1 : md with coupling to temperature bath
 *     temp0 = reference temperature of the bath, to which the system
 *             is coupled (ntt>0)
 *     taut = temperature relaxation time (>0, ntt>0)
 *     boltz = proportionality factor (>0) for calculating the
 *             temperature temp from the total kinetic energy ekin of
 *             the system using the relation: ekin = 3*nat*boltz*temp/2
 *     nstlim = number of md-steps to be performed
 *     t = initial time, just for bookkeeping
 *     dt = md time step
 *     amas = mass of an atom (>0)
 *     epslj = lennard-jones interaction parameter epsilon
 *     siglj = lennard-jones interaction parameter sigma
 *     rcutf = cut-off radius when calculating the interaction
 *             (2*rcutf < minimum of (box(1),box(2),box(3)))
 *     ntpr : results (energies, etc.) are printed every ntpr steps,
 *            see function runmda
 *     ntwx,ntwxm : atomic coordinates are written by function packa to
 *                  trajectory_filename every ntwx time steps, as long as the
 *                  step number < ntwxm+1;
 *     ntpw : controls how function packa writes the md trajectories
 *            (coordinates) to disk
 *          = 0 : unformatted
 *          = 1 : this option is disabled
 *          = 2 : formatted
 *     ngr = number of intervals on the abcis of the radial
 *           distribution function g(r) between 0 and rcutg;
 *           one g(r) value per interval is calculated
 *     rcutg = maximum distance r for which the radial distribution
 *             function g(r) is evaluated
 *             (2*rcutg < minimum of (box(1),box(2),box(3)))
 *
 *     argv[2] (x or x,v):
 *     the data are read in standard binary or standard formatted form,
 *     see program listing below
 *     title1 = arbitrary text, identifying x or v
 *     x = atom cartesian coordinates (time t)
 *     v = atom velocities (time t-dt/2)
 *
 *     trajectory_filename (md trajectory):
 *     every ... steps coordinates can be written to disk by
 *     function packa
 *
 *     finalcoords_filename (final coordinates and velocities):
 *     title, final cartesian coordinates (t) and velocities (t-dt/2)
 *     are written to finalcoords_filename in standard binary form (ntxo=0,2) or
 *     in standard formatted form (ntxo=1).
 *
 *
 */
#include        <iostream>     // For output to terminal
#include        <fstream>      // For file I/O
#include        <iomanip>      // For output format
#include        <cmath>        // For atan(), sqrt() etc.
#include		<chrono>	   // For high resolution timings
#include        <time.h>        // For timing functions

#include        "mdprog.h"     // For function prototypes and
                               //  run-time constants.
using namespace std;

int main(int argc, char *argv[]){

    const double pye   = 4.0*atan(1.0);

    // I/O streams
    ifstream fin1;           // input parameters
    ifstream fin2;           // initial configuration
    ofstream fout1;          // trajectory output
    ofstream fout2;          // final configuration output

    // Strings
    char    title [MAXTITLE], title1 [MAXTITLE];

    // Configuration arrays
    double  x[MAXXCO], v[MAXXCO], f[MAXXCO], gr[MAXNGR], xmin[3];
    int     igr[MAXNGR];

    // Input parameters 
    int     nat;
    int     ntxi, ntxo;
	double  box[3];
	int     nbox[3];
	double  dx;
    int     ig;
    double  tempi;
	int     ntt;
	double  temp0, taut, boltz;
    int     nstlim;
    double  t, dt;
    double  amas, epslj, siglj,rcutf;
	int     ntpr, ntwx,ntwxm,ntpw;
	int     ngr;
    double  rcutg;
    double  dtcoll, gamma, taup, betat; // xxx
	
    // Parameters derived from input parameters 
    int      nat3;
    int      ntxi1;
	int      natom;
    double   sd;             // sqrt(boltz...)
    double   dgr, facgr, r2; // used in radial dist'n func'n calc'n 

    // Other variables
    int      j, j3;
    int      m, n, k;     // array counters

    double   temp;        // temperature (work variable)


    // Timing variables
    time_t   time_0;      // instant execution begins
    time_t   time_start;  // time just before entering runmda()
    time_t   time_end;    // time just after exiting runmda(),now;
    time_t   now;         // instant execution ends
	
    double runmda_diff;   // time spent in runmda()
	double total_diff;    // time spent executing whole code

	
    time(&time_0);
	auto timepoint_0 = std::chrono::high_resolution_clock::now();
    switch ( argc ) {
             case 1: usage(); return (1); break;
             case 2: break;
             case 3: break;
             default: usage(); return (1); break;
    }

    cout << "\n\n PROGRAM PROMDA PERFORMS A MD-RUN" ;
    cout << " FOR A COLLECTION OF ATOMS, USING :\n";
    cout << "    1. DATA CHARACTERIZING THE MD-RUN\n" ;
    cout << "    2. ATOMIC COORDINATES AND VELOCITIES\n\n" ;
/*
 * read data characterizing the md-run
 */
	fin1.open(argv[1], ios::in);
    if(fin1.bad()) {
        cerr << "can't open " << argv[1];
        return(1);
    }

    fin1.getline(title, MAXTITLE);
    fin1 >> nat     >> ntxi    >> ntxo;
    fin1 >> box[0]  >> box[1]  >> box[2];
    fin1 >> nbox[0] >> nbox[1] >> nbox[2] >> dx >> ig >> tempi;
    fin1 >> ntt     >> temp0   >> taut    >> boltz;   
    fin1 >> nstlim  >> t       >> dt;
    fin1 >> amas    >> epslj   >> siglj   >> rcutf ;  
    fin1 >> ntpr    >> ntwx    >> ntwxm   >> ntpw;
    fin1 >> ngr     >> rcutg;   
    fin1 >> dtcoll  >> gamma   >> taup    >> betat; // xxx

    fin1.close();

    

/*
 * print data characterizing the md-run
 */
        cout << "\n\n\n 1.  D A T A   C H A R A C T E R I Z I N G ";
        cout << " T H E   M D - R U N   :\n\n\n" ;
        cout << title << endl ;

        cout << "\n        NAT      NTXI      NTXO\n";
        cout << setw(10) << nat ;
        cout << setw(10) << ntxi ;
        cout << setw(10) << ntxo ;
        cout << "\n";

        cout << "\n     BOX(1)    BOX(2)    BOX(3)\n";
        cout << setw(10) << box[0] ;
        cout << setw(10) << box[1] ;
        cout << setw(10) << box[2] ;
        cout << "\n";

        cout << "\n    NBOX(1)   NBOX(2)   NBOX(3)        DX        IG     TEMPI\n";
        cout << setw(10) << nbox[0] ;
        cout << setw(10) << nbox[1] ;
        cout << setw(10) << nbox[2] ;
        cout << setw(10) << dx      ;
        cout << setw(10) << ig      ;
        cout << setw(10) << tempi   ;
        cout << "\n";

        cout << "\n        NTT     TEMP0      TAUT     BOLTZ\n";
        cout << setw(10) << ntt   ;
        cout << setw(10) << temp0 ;
        cout << setw(10) << taut  ;
        cout << setw(10) << boltz ;
        cout << "\n";

        cout << "\n    NSTLIM          T       DT       DT_COLL\n";
        cout << setw(10) << nstlim ;
        cout << setw(10) << t      ;
        cout << setw(10) << dt     ;
        cout << setw(10) << dtcoll ; // xxx
        cout << "\n";


        cout << "\n       AMAS     EPSLJ     SIGLJ     RCUTF\n";
        cout << setw(10) << amas  ;
        cout << setw(10) << epslj ;
        cout << setw(10) << siglj ;
        cout << setw(10) << rcutf ;
        cout << "\n";

        cout << "\n       NTPR      NTWX     NTWXM      NTPW\n";
        cout << setw(10) << ntpr  ;
        cout << setw(10) << ntwx  ;
        cout << setw(10) << ntwxm ;
        cout << setw(10) << ntpw  ;
        cout << "\n";

        cout << "\n        NGR     RCUTG\n";
        cout << setw(10) << ngr   ;
        cout << setw(10) << rcutg ;
        cout << "\n";

/*
 * evaluate constants
 * check input
 */
        nat3 = 3*nat;
        for(m=0; m<3; m++){
	  xmin[m] = 0;
	}	
        for(m=0; m< MAXNGR; m++){
	  igr[m] = 0;
	}
        if(nat3 > MAXXCO) {
                cout << "3*NAT > MAXXCO\n" ;
                return(1);
        }
        if(box[0] == 0 || box[1] == 0 || box[2] == 0) {
                cout << "BOX[0..2] == 0\n" ;
                return(1);
        }
        if(ntxi == 0 && (nbox[0] == 0 || nbox[1] == 0 || nbox[2] == 0)) {
                cout << "NTXI == 0 and NBOX[0..2] == 0\n" ;
                return(1);
        }
        if(ntxi == 0 && nbox[0]*nbox[1]*nbox[2] > MAXXCO) {
                cout << "NTXI == 0 and NBOX[0]*NBOX[1]*NBOX[2] > MAXXCO\n" ;
                return(1);
        }
        if(ntt > 0 && taut <= 0 && dtcoll<=0) { // xxx
                cout << "NTT > 0 and TAUT == 0 and DT_COLL == 0\n" ;
                return(1);
        }
        if(boltz <= 0) {
                cout << "BOLTZ == 0\n" ;
                return(1);
        }
        if(amas <= 0) {
                cout << "AMAS == 0\n" ;
                return(1);
        }
        if(2*rcutf > box[0] || 2*rcutf > box[1] || 2*rcutf > box[2]) {
                cout << "2*RCUTF > BOX[0..2]\n" ;
                return(1);
        }
        if(ntpr == 0 || ntwx == 0) {
                cout << "NPTR == 0 or NTWX == 0\n" ;
                return(1);
        }
        if(ngr <= 0 || ngr > MAXNGR) {
                cout << "NGR < 1 or NGR > MAXNGR\n" ;
                return(1);
        }
        if(2*rcutg > box[0] || 2*rcutg > box[1] || 2*rcutg > box[2]) {
                cout << "2*RCUTG > BOX[0..1]\n" ;
                return(1);
        }

        // xxx, asserts 
        /*if (dtcoll > 0 && ntt==0){
                cout << "ATTENTION: dtcoll given, but ntt=0. intention?";
                return(1);  
        } 
        if (dt > dtcoll/2){
                cout << "ATTENTION: dt is big in comparison to dt_coll";
                return(1);  
        } */
        if (ntt==2 && dtcoll == 0){
                cout << "ATTENTION: ntt=2 requires dtcoll";
                return(1);    
        }
        if (ntt==3 && gamma == 0){
                cout << "ATTENTION: ntt=3 requires gamma";
                return(1);
        }
        if (ntt==4 && (taup==0 || betat == 0)){
                cout << "ATTENTION: ntt=4 requires taup and betat";
                return(1);
        }



/*
 * generate or read coordinates and velocities, print title
 */
        cout << "\n\n 2.  A T O M I C   C O O R D I N A T E S";
        cout << "  A N D   V E L O C I T I E S   :\n\n";

        ntxi1 = ntxi+1;
        if(ntxi1 > 1) {
           	fin2.open(argv[2], ios::in);
                if(fin2.bad()) {
	          cerr << "can't open " << argv[2];
                  return(1);
                } 
        }
        switch(ntxi1) {
                case 1:
		        confa(box, nbox, xmin, dx, &ig, x);
                        cout << "\n COORDINATES ARE GENERATED";
			cout << " BY SUBR. CONFA\n" ;
                        for(j3=0; j3<nat3; j3++){
  			  v[j3] = 0;
  			}
                        break;

                case 2:
			fin2.getline(title1, MAXTITLE);
                        fin2 >> natom;
                        cout << title1 << "\n";
                        fin2.get();              
                        if(natom < nat) {
			  cout << "NATOM (" << argv[2] << ") = " << natom 
                               << " < NAT\n" ;
                                return(1);
                        }

                        for(j3=0; j3<nat3; j3+=3) {
			  for(m=0; m<3; m++){
			    fin2 >> x[j3+m];
			  }
                        }
                  	fin2.get();      
                        for(j3=0; j3<nat3; j3++){
			  v[j3] = 0;
			}
                        break;

                case 3: 
                        fin2.read(title1, MAXTITLE);
                        cout << title1 << "\n";
                        readdbl(fin2, x, nat3);
                        for(j3=0; j3<nat3; j3++)
                                v[j3] = 0;
                        break;

                case 4:
			fin2.getline (title1, MAXTITLE);
                        cout << title1 << "\n";
                        fin2 >> natom;
                        fin2.get(); 
                        if(natom < nat) {
			        cout << "NATOM (" << argv[2] << ") < NAT\n";
                                return(1);
                        }
                        for(j3=0; j3<nat3; j3+=3) {
                                fin2 >> k;
                                for(m=0; m<3; m++){
				  fin2 >> x[j3+m];
				}
                                for(m=0; m<3; m++){
				  fin2 >> v[j3+m];
				}
                        }
                        fin2.get();
                        break;

                case 5: 
                        fin2.read(title1, MAXTITLE);
                        cout << title1 << "\n";
                        readdbl(fin2, x, nat3);
                        readdbl(fin2, v, nat3);
                        break;
        }

        if (ntxi>1){
	  fin2.close();
	}

/*
 * take the velocities from a maxwellian, when required
 */
          if(tempi >= 1e-6) {
  	          cout << "\n VELOCITIES ARE TAKEN";
		  cout <<" FROM A MAXWELLIAN DISTRIBUTION\n\n\n";
                  sd = sqrt(boltz*tempi/amas);
		  for(j3=0; j3<nat3; j3++) {
		         v[j3] = gauss(0.0, sd, &ig);
                  }
          }
/*
 * write title to trajectory file when required
 */
      if(ntwxm >0  && ntpw == 0) {
           	fout1.open(trajectory_filename,ios::out);
                if(fout1.bad()) {
	           cerr << "can't open " << "trajectories.out";
                   return(1);
                }
                fout1.write(title, MAXTITLE*sizeof(char));
                fout1.close();
      }
      if(ntwxm > 0 && ntpw == 2) {
           	fout1.open(trajectory_filename, ios::out);
                if(fout1.bad()) {
	           cerr << "can't open " << "trajectories.out";
                   return(1);
                }
                fout1 << title << endl;
                fout1.close();
      }
/*
 * perform md-run
 */
      time(&time_start);
	  auto timepoint_start = std::chrono::high_resolution_clock::now();
      runmda(nat, x, v, f, amas, epslj, siglj, rcutf, box, nstlim, t,
             dt, ntt, temp0, taut, boltz, &temp, ntpr, ntwx, ntwxm,
             ntpw, rcutg,  ngr, igr, dtcoll, ig, gamma, taup, betat);
      time(&time_end);
	  auto timepoint_end = std::chrono::high_resolution_clock::now();

/*
 * plot the radial distribution function
 */
        if(rcutg > 0 && nat > 1) {
                cout << "\n\n RADIAL DISTRIBUTION FUNCTION G(R) :\n\n" ;
		cout << "        R        g(R)\n" ;
                dgr = rcutg/ngr;
                facgr = box[0]*box[1]*box[2]/(nat*(nat-1)*2*pye*dgr*nstlim);
                for(n=0; n<ngr; n++) {
                        r2 = ((n+1)*dgr)*((n+1)*dgr);
                        gr[n] = igr[n]*facgr/r2;
			cout << setw(10) << (n+0.5)*dgr ;
                        cout << setw(15) << gr[n] <<"\n";
                }
		cout << "\n\n" ;
        }
/*
 * write title, final coordinates and velocities
 */

        if(ntxo == 1) {
                fout2.open(finalcoords_filename,ios::out);
                if(fout2.bad()) {
                  cerr << "can't open " << "final_coords.out\n";
                  return(1);
                }
                fout2 << title << "\n" ;
                fout2 << nat   << "\n" ;
                for(j=0; j<nat; j++) {
                        fout2 << j;
                        for(m=0; m<3; m++){
			  fout2 << setw(10) << x[3*j+m];
			}
                        for(m=0; m<3; m++){
			  fout2 << setw(10) << v[3*j+m];
		        }
            		fout2 << "\n";
		}
        }
        else {
                fout2.open(finalcoords_filename,ios::out | ios::binary);
                if(fout2.bad()) {
                  cerr << "can't open " << "final_coords.out\n";
                  return(1);
                }
                fout2.write(title, MAXTITLE); 
                writedbl(fout2, x,  nat3);
                writedbl(fout2, v,  nat3);
        }
        fout2.close();

		cout << "TIMING:" << endl << endl;
		cout << "  At start of program:    " 
             << ctime(&time_0) << endl ;
        cout << "  Before calling runmda:  " 
             << ctime(&time_start) << endl ;
        cout << "  After calling runmda:   " 
             << ctime(&time_end) << endl ;

	    now = time((time_t*)NULL);
        cout << "  Now:                    " 
             << ctime(&now)  << endl;

        runmda_diff = difftime (time_end,time_start);
        total_diff  = difftime (now,time_0);
        cout << "  Time spent in runmda:   " 
             << runmda_diff << " sec" << endl ;
        cout << "  Time spent in total:    " 
             << total_diff  << " sec" << endl ;     
        
        cout << endl << endl;
		auto timepoint_now = std::chrono::high_resolution_clock::now();
        cout << "MORE ACCURATE TIMING:" << endl << endl;
        cout << "  Time spend in runmda:   " << std::chrono::duration_cast<std::chrono::milliseconds>(timepoint_end-timepoint_start).count() << " ms" << endl;
		cout << "  Time spend in total:    " << std::chrono::duration_cast<std::chrono::milliseconds>(timepoint_now - timepoint_0).count() << " ms" << endl;

        return (0);
}

